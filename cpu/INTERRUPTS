How to create and manage interrupts

First, write the interrupt handler that should
be called in isr.c and add its header to isr.h. Add
   [extern <int_handler_name>] 
to the top of interrupt.asm
In interrupt.asm, write
   global isr<int#>
   isr<int#>:
      push byte <int#> (if number 9-14)
      push byte <int#>
      SETUP_INT
      call <int_handler_name>
      END_INT
Finally, in the isr.c install_isrs function
add
   add_idt_entry( <int#>, (u32)isr<int#>);   

There is a slight variation on interrupts. When
the interrupt is called as a result of the PIC,
the byte 0x20 must be sent to re-enable the interrupt
capabilities of the PIC.


Conceptual map of how interrupts flow through the system

Interrupts   in                in isr.c
called       interrupt.asm

INT 1  - - - isr1: - - - - \ 
INT 2  - - - isr2: - - - - -- main_int_handler 
INT 3  - - - isr3: - - - - /   -> array_of_function\
                               -> pointers[int#]     -> void int_1_handle() ...

Conceptual map of how the interrupt initilization functions work

install_interrupts -> add_idt_entry(<int#>, (u32)isr<int#>)
             -> Initilize IDT
All of the <int#>'s are pointing to main_int_handler. 
Getting an interrupt working requires two things:
add_idt_entry(<int#>, (u32)isr<int#>) in install_interrupts so that 
and interrupt goes
   INT 20 -> isr20: -> main_int_handler
Then the interrupt handler needs to be registered so that
main_int_handler
  -> array_of_function_handlers[<int#>]()

Note that an interrupt can be initilized in the IDT, but not have a
handler (in which case, a default handler by main_int_handler is called)
and the handler can be registered, but the interrupt has not been added
to the IDT (in which case, the interrupt will never be called)



