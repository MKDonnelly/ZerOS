Model for Design:
   Everything is a file. Processes are files. Data is stored in files.
   All processes communicate using messages. System calls are simply
   a specific type of message. IPC between processes is simple another
   specific type of message. Signals are specific type of messages.
   Network communication is simply a specific type of message. All
   communication is just a message. Every entity has a complete URL.
   i.e. /usr/bin/ls would end up as file:/usr/bin/ls, a process could
   be addressed as process:myprocess, a thread could be addressed as
   thread:myprocess/thread1, a process on a remote machine could be
   represented as network:192.168.1.254/process:remote_process, etc.

message example:
   typedef struct message
      int type;
      int channel;
      int len;
      void *content;
   }message_t;
   ...
   sysread_content request = {CHANNEL_TO_READ, SIZE, BUFFER, SYNCRONOUS};
   message_t syscall_read = {MSG_SYSREAD, MSG_KERNEL, sizeof(request), &request};
   send(syscall_read);
   
   With this abstraction, there would only be three things on the system:
   files, entities, and a small set of system calls to manage messages. 
   There will be a series of channels that messages can be sent/received
   from. There will be four default channels: channel 0 will be for input,
   channel 1 will be for output, channel 2 will be for error, and channel
   4 will be for kernel communication. We can also register functions to
   be called when a message is received on a channel. This is much like
   how signals work on linux.

Idea: Have a shared-memory interface between the kernel and userland
      to reduce cost of message passing. Make a message-passing heap
      that can be used.
System calls:
   msg_send(...)
   msg_recv(...)
   channel_setup(...)
   channel_destroy(...)
   channel_handle(...)
   channel_unhandle(...)
   

Multitasking
   program execution
      work on elf linking and loading
      READ MAN ELF!
   Look into what vDSO is (man vdso)
   create systemcall interface 
      for blocking system calls, we need to push the kernel-mode state
      onto the stack and then switch to another thread.
   Symmetric Multi Processing (SMP) (see intel multiprocessor spec)
   Work on scheduler
   Create message passing interface and shared memory for IPC, signals
   Add name to task_t
   Utilize page faults better (kill task that makes a page fault,etc)
   Unify message passing and signals: signals are just special messages

drivers
   APIC, HPET, ATA non-PIO mode, PCI, network card
   basic ext2 filesystem

make a modular kernel
priority lock based on priority queue implemented as min heap
make a queue-based mutex
Use kassert often
Database-fs: Within a file, create a key-value store to associate
             a certain key with a block of data.
Heap ideas
   - Add in hints (i.e. this memory will be temp, or long term)
   - Add in allocator pre-allocs (i.e. we will need to allocate 100 4k
                                       frames in the future, prepare)

printing/screen manipulation:
  Double buffering, frame buffer
  VGA 13h mode driver (shapes, graphics)
  Get a dump of the vga font and create custom font 
  Add more vga register modes (get higher res dumps using qemu)
  use hwinfo --framebuffer to see and program video modes
    also use grub gfx directive to boot into a higher video mode
  make routines for 1024x768 graphics mode (set by multiboot header)

misc tasks 
   use syscall/sysret instead of interrupt
   Create /dev virtual directory
   port zeros to xen
   port over a c library (newlib, uClib, musl)
   Add a how-to to explain how each subsystem works
   Add examples for each subsystem for reference
      and list the dependencies
   Create a slab allocator to be placed over the generic
      heap. e.g. paging stuff requires a lot of 4K pages
      aligned on 4K; have a slab allocator catch those and
      have the generic slab as a backup
   Let heap code accept hints. i.e. this memory will be allocated
      for a long/short time, expands/does not expand, etc. Have long
      term allocations start at head of memory, and short term allocations
      start at the end of memory. They then grow towards one another.

advanced os examples:
   dragonfly bsd, minix, plan9, genode, haiku, helenos, redox

low-priority
   add random number generator
   Get proper release/press code working with keyboard
   use timer channel 2 to play sound on pc speaker
   work on arm arch code with qemu-arm
